<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on tail -f /var/log/buddyspike</title>
    <link>https://buddyspike.github.io/blog/posts/</link>
    <description>Recent content in Posts on tail -f /var/log/buddyspike</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; &lt;a href=&#34;https://github.com/buddyspike&#34;&gt;buddyspike&lt;/a&gt; 2017</copyright>
    <lastBuildDate>Sun, 18 Jun 2017 11:04:09 +1000</lastBuildDate>
    
	<atom:link href="https://buddyspike.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go Channels</title>
      <link>https://buddyspike.github.io/blog/posts/golang-channels/</link>
      <pubDate>Sun, 18 Jun 2017 11:04:09 +1000</pubDate>
      
      <guid>https://buddyspike.github.io/blog/posts/golang-channels/</guid>
      <description>Channels and goroutines in golang is a novel approach to composition of concurrent programs. Correct use of them leads us into more understandable concurrent programs. This is a compilation of little things that I find useful when using channels.
Fine-grained channel types Specifying fine-grained channel types makes it easier to reason about go routines. Consider two routines, producer and consumer communicating via a channel.
func producer(c chan&amp;lt;- string) { &amp;lt;-c // compile error } func consumer(c &amp;lt;-chan string) { c&amp;lt;- &amp;quot;a&amp;quot; // compile error } c := make(chan string) go producer(c) go consumer(c)  With fine-grained channel types in producer and consumer functions, compiler will ensure that they can only either read or write to the channel.</description>
    </item>
    
  </channel>
</rss>